# 不可变类

## 1. **数据传输对象 (DTO/Model)**

```dart
// API响应数据模型
class UserProfile {
  final String id;
  final String username;
  final String email;
  final DateTime createdAt;
  
  const UserProfile({
    required this.id,
    required this.username,
    required this.email,
    required this.createdAt,
  });
  
  // 从JSON创建
  factory UserProfile.fromJson(Map<String, dynamic> json) {
    return UserProfile(
      id: json['id'],
      username: json['username'],
      email: json['email'],
      createdAt: DateTime.parse(json['created_at']),
    );
  }
}
```

## 2. **配置和设置类**

```dart
// 应用配置
class AppConfig {
  final String apiBaseUrl;
  final int timeoutSeconds;
  final bool enableLogging;
  final String version;
  
  const AppConfig({
    required this.apiBaseUrl,
    this.timeoutSeconds = 30,
    this.enableLogging = false,
    required this.version,
  });
  
  // 预定义配置
  static const AppConfig development = AppConfig(
    apiBaseUrl: 'https://dev-api.example.com',
    enableLogging: true,
    version: '1.0.0-dev',
  );
  
  static const AppConfig production = AppConfig(
    apiBaseUrl: 'https://api.example.com',
    version: '1.0.0',
  );
}
```

## 3. **值对象 (Value Objects)**

```dart
// 货币金额
class Money {
  final double amount;
  final String currency;
  
  const Money(this.amount, this.currency);
  
  Money operator +(Money other) {
    if (currency != other.currency) {
      throw ArgumentError('Currency mismatch');
    }
    return Money(amount + other.amount, currency);
  }
  
  @override
  bool operator ==(Object other) {
    return other is Money && 
           amount == other.amount && 
           currency == other.currency;
  }
  
  @override
  int get hashCode => Object.hash(amount, currency);
}

// 地理坐标
class Coordinate {
  final double latitude;
  final double longitude;
  
  const Coordinate(this.latitude, this.longitude);
  
  double distanceTo(Coordinate other) {
    // 计算距离的逻辑
    return 0.0; // 简化示例
  }
}
```

## 4. **事件和消息类**

```dart
// 事件驱动架构中的事件
abstract class Event {
  final DateTime timestamp;
  final String eventId;
  
  const Event(this.timestamp, this.eventId);
}

class UserRegisteredEvent extends Event {
  final String userId;
  final String email;
  
  const UserRegisteredEvent({
    required this.userId,
    required this.email,
    required DateTime timestamp,
    required String eventId,
  }) : super(timestamp, eventId);
}

class OrderCreatedEvent extends Event {
  final String orderId;
  final String customerId;
  final double totalAmount;
  
  const OrderCreatedEvent({
    required this.orderId,
    required this.customerId,
    required this.totalAmount,
    required DateTime timestamp,
    required String eventId,
  }) : super(timestamp, eventId);
}
```

## 5. **状态管理中的状态类**

```dart
// 应用状态 (常用于Flutter状态管理)
class AppState {
  final bool isLoading;
  final String? error;
  final List<String> items;
  final UserProfile? currentUser;
  
  const AppState({
    this.isLoading = false,
    this.error,
    this.items = const [],
    this.currentUser,
  });
  
  AppState copyWith({
    bool? isLoading,
    String? error,
    List<String>? items,
    UserProfile? currentUser,
  }) {
    return AppState(
      isLoading: isLoading ?? this.isLoading,
      error: error ?? this.error,
      items: items ?? this.items,
      currentUser: currentUser ?? this.currentUser,
    );
  }
  
  // 清除错误状态
  AppState clearError() => copyWith(error: null);
  
  // 设置加载状态
  AppState setLoading(bool loading) => copyWith(isLoading: loading);
}
```

## 6. **缓存键和标识符**

```dart
// 缓存键
class CacheKey {
  final String prefix;
  final String identifier;
  final Map<String, String> parameters;
  
  const CacheKey({
    required this.prefix,
    required this.identifier,
    this.parameters = const {},
  });
  
  String get key {
    var key = '$prefix:$identifier';
    if (parameters.isNotEmpty) {
      var paramString = parameters.entries
          .map((e) => '${e.key}=${e.value}')
          .join('&');
      key += '?$paramString';
    }
    return key;
  }
  
  @override
  bool operator ==(Object other) {
    return other is CacheKey &&
           prefix == other.prefix &&
           identifier == other.identifier &&
           const MapEquality().equals(parameters, other.parameters);
  }
}
```

## 7. **查询和过滤条件**

```dart
// 数据库查询条件
class QueryFilter {
  final String? search;
  final DateTime? startDate;
  final DateTime? endDate;
  final List<String> categories;
  final int limit;
  final int offset;
  
  const QueryFilter({
    this.search,
    this.startDate,
    this.endDate,
    this.categories = const [],
    this.limit = 20,
    this.offset = 0,
  });
  
  QueryFilter copyWith({
    String? search,
    DateTime? startDate,
    DateTime? endDate,
    List<String>? categories,
    int? limit,
    int? offset,
  }) {
    return QueryFilter(
      search: search ?? this.search,
      startDate: startDate ?? this.startDate,
      endDate: endDate ?? this.endDate,
      categories: categories ?? this.categories,
      limit: limit ?? this.limit,
      offset: offset ?? this.offset,
    );
  }
}
```

## **不可变类的主要优势：**

1. **线程安全** - 天然线程安全，无需同步
2. **缓存友好** - 可以安全地缓存hashCode
3. **函数式编程** - 支持函数式编程范式
4. **调试友好** - 状态不会意外改变，易于调试
5. **性能优化** - 编译器可以进行更多优化
6. **预测性** - 行为更可预测，减少bug

## **使用场景总结：**

- ✅ 数据传输和序列化
- ✅ 配置和常量
- ✅ 值对象和计算
- ✅ 事件和消息
- ✅ 状态管理
- ✅ 缓存键和标识
- ✅ 查询条件和过滤器
- ✅ 函数式编程
- ❌ 需要频繁修改的业务逻辑对象
- ❌ 性能敏感的大数据操作

选择不可变类的关键是：**数据的生命周期中是否需要修改，以及是否需要在多个地方安全地共享数据**。
